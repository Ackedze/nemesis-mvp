# Nemesis MVP Plugin

## Обзор
`nemesis-mvp` — это плагин для Figma, который делает аудит узлов Figma относительно локальных справочников Nemesis, визуализирует
различия по категориям (актуальные компоненты, кастомизация, ошибки темизации и т.д.), позволяет быстро фокусировать слои и
обменивается данными с текстогенераторным модулем.

## Структура проекта
- `src/code.ts` — основной движок плагина: он слушает UI-уведомления, запускает `runAudit`, ходит в справочники,
  строит `AuditItem` и вычисляет `diff`s между узлами и эталонами.
- `src/ui.html` — интерфейс: табы, карточки, фильтры, показ баннеров, генерация `content-line` карточек и показ Toast.
- `src/services/auditViewBuilder.ts` — модуль, собирающий справочные записи (детачи, текстовые узлы, кастомные стили), фильтрующий видимость и рассчитывающий `changesResults`, чтобы UI работал с предвычисленными списками.
- `src/utils/nodeHelpers.ts` — общие хелперы по вычислению видимости и путей узлов.
- `src/config/tabs.ts` — единый источник описаний табов, их названий, билдверов и сообщений об отсутствии данных.
- `src/icons.ts` — хранятся SVG-данные для иконок видимости.
- `src/structure/` — сериализация дерева (`snapshot`) и различия (`diffStructures`).
- `src/reference/` — загрузка и кеширование каталогов (компоненты, токены, стили).
- `src/utils/` — вспомогательные утилиты (fetch, форматирование).
- `scripts/` — сборка справочников (кеш менеджеры, экспорты).

## Модели и данные
- `AuditItem` (в `code.ts`) — основная модель, описывающая узел: `id`, имя, путь, видимость, статус темы, источники, `diffs`, причины кастомизации, ссылки на справочники и ключ компонента.
- `DiffEntry` — разница между фактическим и эталонным представлением узла (сообщение, nodeId, nodePath, `visible`, `tokenLabel`).
- UI-структуры (`nemesis-mvp/src/ui.html`) используют `content-line` + `middle-line` как повторно используемый компонент карточки, а конфигурация табов и билдверов поступает из `tab-config`, что позволяет переиспользовать `buildCardLine` и единый рендерер.

## Взаимодействие компонентов
1. UI отправляет `scan-selection` → `code.ts` запускает `runAudit`.
2. Перед отрисовкой табов движок высылает в UI сообщение `tab-config`, чтобы интерфейс использовал те же определения (`id`, `title`, `builder`, `ignoreComponentFilter` и т.д.) из `src/config/tabs.ts`.
3. В `runAudit` загружаются справочники, снимается дерево (`snapshotTree`), сравнивается (`diffStructures`), классифицируются все узлы (`classifyNode`) и формируются коллекции для табов (`current`, `detached`, `changes`, `local`, `customStyles`, `textAll` и т.д.).
4. Результат (`currentResults`, `changesResults`, `detachedEntries`, `textNodes`, `customStyles`) отправляется в UI вместе с предварительно отфильтрованными `visibleViews` и отдельным полным массивом `changes`. UI просто переключает источник между `views` и `visibleViews`, а таб «Кастомизация» рендерит `views.changes`/`visibleViews.changes`, не выполняя дополнительных фильтров.
5. `filters.visibleOnly` и `componentsOnly` применяются при отборе узлов (`applyFilters`), а `prepareChangeDiffs` дополнительно дублирует и очищает diff-ы для «Кастомизации».

## Фильтры и вычисления
- Таб `Кастомизация` получает diff-только если для инстанса реально есть отличия от варианта **и** элемент видим — скрытые ветки отбрасываются.
- UI обновляет счетчики вместе с фильтром «только видимые» — `visibleViews` передаются параллельно `views`, потому что табы рендерят либо весь набор, либо уже предфильтрованные данные.
- Компоненты, токены и стили загружаются единым пулом справочников, поэтому ссылки в таблице соответствуют источникам из `JSONS-MVP/` после генерации `referenceSourcesMVP.json`.
- `snapshotNormalizedContext` и `snapshotTree` теперь проставляют флаг `visible` с учётом родителей, чтобы диффы не теряли контекст видимости.

## Развитие и улучшения
- **Модульность**: стоит вынести `reference`/`structure`-логики в отдельные npm-пакеты, чтобы легче было тестировать и использовать на бэкенде.
- **Формат diff результатов**: `prepareChangeDiffs` уже фильтрует "технические" строки; будущие улучшения могут включать группировку diff-ов по компонентам и версии.
- **Производительность**: `runAudit` можно распараллеливать через `Promise.all`, а результаты кешировать, чтобы при повторных сканах не пересчитывать неизменные узлы.
- **Backend-наблюдение**: если сделать API-сервис, то UI будет только принимать JSON с предварительно подготовленными табами.
- **Унификация карточек**: в `src/ui.html` вынесена функция `buildCardLine`, чтобы все табы делились единым механизмом композиции строк и кнопки `focus`.

## Сборка и запуск
```bash
cd Nemesis-mvp
npm install
npm run build  # запускает esbuild + экспорт дерева компонентов
```

### После каждой правки
Так как плагин статичен (HTML + bundle), после любого изменения в `src/` всегда запускайте:

```bash
cd Nemesis-mvp
npm install     # только один раз, если не выполнено ранее
npm run build   # пересобирает bundle и заполняет dist/
```

`npm run build` выполняет esbuild, пересоздаёт `dist/code.js`, копирует UI и экспортирует дерево компонентов для отладки.
